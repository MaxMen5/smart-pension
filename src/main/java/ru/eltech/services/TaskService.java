package ru.eltech.services;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import ru.eltech.config.TasksConfig;
import ru.eltech.dto.tasks.*;
import ru.eltech.dto.workers.WorkerInRoomDto;
import ru.eltech.entity.*;
import ru.eltech.exception.MyException;
import ru.eltech.repositories.*;
import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class TaskService {

    private final TaskRepository taskRepository;
    private final RoomRepository roomRepository;
    private final WorkerScheduleRepository workerScheduleRepository;
    private final WorkerRepository workerRepository;
    private final TasksConfig tasksConfig;

    public TaskService(final TaskRepository taskRepository, final RoomRepository roomRepository, final WorkerScheduleRepository workerScheduleRepository, final WorkerRepository workerRepository, TasksConfig tasksConfig) {
        this.taskRepository = taskRepository;
        this.roomRepository = roomRepository;
        this.workerScheduleRepository = workerScheduleRepository;
        this.workerRepository = workerRepository;
        this.tasksConfig = tasksConfig;
    }

    @Transactional
    public void generateTasks() {
        if (roomRepository.findAll().isEmpty()) return;
        LocalDate today = LocalDate.now();
        LocalDate endDate = today.plusDays(tasksConfig.getDaysAhead());
        for (LocalDate date = today; !date.isAfter(endDate); date = date.plusDays(1)) {
            if (taskRepository.countByTaskDate(date) != 0) continue; // если нет задач на день ни одной!
            List<Room> allRooms = roomRepository.findAll();
            List<TasksConfig.DailyTask> templates = tasksConfig.getDaily();
            for (Room room : allRooms) {
                for (TasksConfig.DailyTask template : templates) {
                    Task task = new Task();
                    task.setTitle(template.getTitle());
                    task.setDescription(template.getDescription());
                    task.setTaskDate(date);
                    task.setRoom(room);
                    task.setIsCompleted(false);
                    task.setIsAutoGenerated(true);
                    taskRepository.save(task);
                }
            }
        }
    }


    @Transactional(readOnly = true)
    public DailyRoomTasksDto getDailyTasks(LocalDate date) {
        // Получаем все комнаты
        List<Room> allRooms = roomRepository.findAllByOrderByRoomNumberAsc();

        // Создаем мапу для быстрого доступа к задачам по комнатам
        Map<Long, List<Task>> tasksByRoom = taskRepository.findByTaskDate(date).stream()
                .collect(Collectors.groupingBy(task -> task.getRoom().getId()));

        // Получаем всех сотрудников, работающих в этот день
        List<Worker> workingWorkers = workerScheduleRepository.findWorkersByWorkDate(date);
        Map<Long, Worker> workingWorkersMap = workingWorkers.stream()
                .collect(Collectors.toMap(Worker::getId, w -> w));

        // Для каждой комнаты собираем данные
        List<RoomTasksDto> roomDTOs = allRooms.stream()
                .map(room -> convertRoomToDTO(room, date, tasksByRoom.get(room.getId()), workingWorkersMap))
                .collect(Collectors.toList());

        return new DailyRoomTasksDto(date, roomDTOs);
    }

    private RoomTasksDto convertRoomToDTO(Room room, LocalDate date,
                                          List<Task> tasks, Map<Long, Worker> workingWorkersMap) {
        // Получаем задачи комнаты
        List<TaskStatusDto> taskDTOs;
        int totalTasks;
        int completedTasks;

        if (tasks != null) {
            taskDTOs = tasks.stream()
                    .map(this::convertTaskToDTO)
                    .collect(Collectors.toList());
            totalTasks = tasks.size();
            completedTasks = (int) tasks.stream()
                    .filter(Task::getIsCompleted)
                    .count();
        } else {
            taskDTOs = Collections.emptyList();
            totalTasks = 0;
            completedTasks = 0;
        }

        // Получаем сотрудников, закрепленных за комнатой И работающих в этот день
        List<WorkerInRoomDto> workersInRoom = room.getWorkers().stream()
                .filter(worker -> workingWorkersMap.containsKey(worker.getId()))
                .map(this::convertWorkerToDTO)
                .collect(Collectors.toList());

        return new RoomTasksDto(
                room.getId(),
                room.getRoomNumber(),
                room.getRoomType(),
                room.getFreeSpots(),
                workersInRoom,
                taskDTOs,
                completedTasks,
                totalTasks
        );
    }

    private TaskStatusDto convertTaskToDTO(Task task) {
        String completedByWorkerLogin = null;

        // Если есть исполнитель, получаем его логин
        if (task.getCompletedByWorkerId() != null) {
            completedByWorkerLogin = workerRepository.findById(task.getCompletedByWorkerId())
                    .map(Worker::getLogin)
                    .orElse(null);
        }

        return new TaskStatusDto(
                task.getId(),
                task.getTitle(),
                task.getDescription(),
                task.getIsCompleted(),
                task.getCompletedByWorkerId(),
                completedByWorkerLogin
        );
    }

    private WorkerInRoomDto convertWorkerToDTO(Worker worker) {
        return new WorkerInRoomDto(
                worker.getId(),
                worker.getLogin(),
                worker.getShift()
        );
    }





    @Transactional
    public void deleteTask(Long taskId) {

        // Находим задачу
        Task task = taskRepository.findById(taskId)
                .orElseThrow(() -> new MyException("Задача не найдена"));

        // Проверяем дату задачи
        LocalDate today = LocalDate.now();
        LocalDate maxAllowedDate = today.plusDays(7);

        if (task.getTaskDate().isBefore(today)) {
            throw new RuntimeException("Нельзя удалять задачи за прошедшие даты");
        }

        if (task.getTaskDate().isAfter(maxAllowedDate)) {
            throw new RuntimeException("Нельзя удалять задачи более чем на неделю вперед");
        }

        // Удаляем
        taskRepository.delete(task);
    }

    @Transactional
    public TaskStatusDto createTask(CreateTaskDto request) {
        // Валидация даты
        LocalDate taskDate = request.taskDate() != null ? request.taskDate() : LocalDate.now();
        LocalDate today = LocalDate.now();
        LocalDate maxAllowedDate = today.plusDays(7);

        if (taskDate.isBefore(today)) {
            throw new MyException("Нельзя создавать задачи за прошедшие даты");
        }

        if (taskDate.isAfter(maxAllowedDate)) {
            throw new MyException("Нельзя создавать задачи более чем на неделю вперед");
        }

        // Проверяем комнату
        Room room = roomRepository.findById(request.roomId())
                .orElseThrow(() -> new MyException("Комната не найдена"));

        // Создаем задачу
        Task task = new Task();
        task.setTitle(request.title());
        task.setDescription(request.description());
        task.setTaskDate(taskDate);
        task.setRoom(room);
        task.setIsCompleted(false);
        task.setIsAutoGenerated(false); // Ручное создание

        // Сохраняем
        Task savedTask = taskRepository.save(task);

        // Возвращаем DTO
        return convertTaskToDTO(savedTask);
    }














    @Transactional(readOnly = true)
    public DailyRoomTasksDto getWorkerTasks(String login) {
        // Проверяем, что сотрудник существует
        Worker worker = workerRepository.findByLogin(login)
                .orElseThrow(() -> new MyException("Сотрудник не найден"));

        LocalDate today = LocalDate.now();

        // Проверяем, работает ли сотрудник сегодня
        boolean isWorkingToday = workerScheduleRepository.existsByWorkerIdAndWorkDate(worker.getId(), today);
        if (!isWorkingToday) throw new MyException("Вы не работаете сегодня");

        // Вариант A: Если у Room есть связь с Worker
        List<Room> workerRooms = roomRepository.findByWorkersId(worker.getId());

        // 2. Получаем задачи для этих комнат на сегодня
        Map<Long, List<Task>> tasksByRoom = taskRepository.findByTaskDate(today).stream()
                .filter(task -> workerRooms.stream()
                        .anyMatch(room -> room.getId().equals(task.getRoom().getId())))
                .collect(Collectors.groupingBy(task -> task.getRoom().getId()));

        // 3. Формируем DTO для каждой комнаты
        List<RoomTasksDto> roomDTOs = workerRooms.stream()
                .map(room -> {
                    List<Task> tasks = tasksByRoom.get(room.getId());
                    return convertWorkerRoomToDTO(room, tasks, worker);
                })
                .filter(roomDto -> !roomDto.tasks().isEmpty()) // Фильтруем комнаты без задач
                .collect(Collectors.toList());

        return new DailyRoomTasksDto(today, roomDTOs);
    }

    private RoomTasksDto convertWorkerRoomToDTO(Room room, List<Task> tasks, Worker worker) {
        List<TaskStatusDto> taskDTOs;
        int totalTasks;
        int completedTasks;

        if (tasks != null && !tasks.isEmpty()) {
            taskDTOs = tasks.stream()
                    .map(this::convertTaskToDTO)
                    .collect(Collectors.toList());
            totalTasks = tasks.size();
            completedTasks = (int) tasks.stream()
                    .filter(Task::getIsCompleted)
                    .count();
        } else {
            taskDTOs = Collections.emptyList();
            totalTasks = 0;
            completedTasks = 0;
        }

        // Для сиделки показываем только ее саму как ответственную
        List<WorkerInRoomDto> workersInRoom = Collections.singletonList(
                new WorkerInRoomDto(worker.getId(), worker.getLogin(), worker.getShift())
        );

        return new RoomTasksDto(
                room.getId(),
                room.getRoomNumber(),
                room.getRoomType(),
                room.getFreeSpots(),
                workersInRoom,
                taskDTOs,
                completedTasks,
                totalTasks
        );
    }









    @Transactional
    public TaskStatusDto toggleTaskCompletion(Long taskId, CompleteTaskDto request) {
        // Находим задачу
        Task task = taskRepository.findById(taskId)
                .orElseThrow(() -> new MyException("Задача не найдена"));

        // Проверяем сотрудника
        Worker worker = workerRepository.findByLogin(request.login())
                .orElseThrow(() -> new MyException("Сотрудник не найден"));

        // Проверяем, что задача на сегодня
        LocalDate today = LocalDate.now();
        if (!task.getTaskDate().equals(today)) {
            throw new MyException("Можно отмечать только задачи на сегодня");
        }

        // Проверяем, работает ли сотрудник сегодня
        boolean isWorkingToday = workerScheduleRepository.existsByWorkerIdAndWorkDate(worker.getId(), today);
        if (!isWorkingToday) {
            throw new MyException("Вы не работаете сегодня");
        }

        // Проверяем, закреплен ли сотрудник за комнатой
        boolean isAssignedToRoom = task.getRoom().getWorkers().stream()
                .anyMatch(w -> w.getId().equals(worker.getId()));
        if (!isAssignedToRoom) {
            throw new MyException("Вы не закреплены за этой комнатой");
        }

        // Обновляем статус задачи
        if (request.isCompleted() != null) {
            // Если передали конкретный статус
            task.setIsCompleted(request.isCompleted());
            if (request.isCompleted()) {
                task.setCompletedByWorkerId(worker.getId());
            } else {
                task.setCompletedByWorkerId(null);
            }
        } else {
            // Или переключаем текущий статус
            task.setIsCompleted(!task.getIsCompleted());
            if (task.getIsCompleted()) {
                task.setCompletedByWorkerId(worker.getId());
            } else {
                task.setCompletedByWorkerId(null);
            }
        }

        // Сохраняем изменения
        Task updatedTask = taskRepository.save(task);

        // Возвращаем обновленную задачу
        return convertTaskToDTO(updatedTask);
    }
}